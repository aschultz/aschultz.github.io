<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><link rel="preload" href="/fonts/UrbanistGX.ttf" as="font" type="font/ttf"><link rel="canonical" href="https://aschultz.github.io/posts/2011/2011-02-13_projectivetexturing/"><title>Projective Texturing</title><meta name="title" content="Projective Texturing"><meta name="description" content="How to map the vertices of a scene into shadow map texture space"><link rel="stylesheet" href="/astro/about.db97af40.css" /></head><body><div class="siteRoot"><div class="bg"><div class="bg-left"></div><div class="bg-main"></div><div class="bg-right"></div></div><header><nav class="siteNav"><a href="/"><h1>a.schultz</h1></a><ul><li><a href="/about/">About</a></li><li><a href="https://github.com/aschultz" title="GitHub"><img src="/icons/GitHub-Mark.inline.svg"></a></li><li><a href="https://www.linkedin.com/in/-aschultz" title="LinkedIn"><img src="/icons/LinkedIn.inline.svg"></a></li></ul></nav></header><main><article class="cbox" itemscope itemtype="http://schema.org/Article"><header class="ccontent"><h1 itemprop="name headline">Projective Texturing</h1><time itemprop="datePublished" datetime="2011-02-13T00:00:00.000Z">Sat Feb 12 2011 16:00:00 GMT-0800 (Pacific Standard Time)</time></header><div class="ccontent" itemprop="articleBody"><p>While working on my shadow mapping system, I finally figured out how to correctly map vertex positions from my scene into shadow map texture space. It’s not super complicated, but I had to scrounge around a lot on the web to come up with a satisfying list of operations. Hopefully the following code can help others get there faster.</p>
<p>In my system, as with most, we render the scene from the light’s POV and save the depth data. We then render the scene from the camera’s POV and use the generated shadow map to calculate whether pixels seen by the camera are shadowed or not. This second stage requires taking vertex positions from an object and (in the vertex and pixel shaders) converting them into shadow-map texture coordinates so that we can sample from the shadow map correctly. To do this, we can generate a matrix to get most of the way there and then use tex2Dproj to do the texture lookup.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" lang="cpp"><code><span class="line"><span style="color:#6A737D">/// &#x3C;summary></span></span>
<span class="line"><span style="color:#6A737D">/// Generates a matrix the converts from projection space to [0,1] texture space</span></span>
<span class="line"><span style="color:#6A737D">/// for projective texturing, flipping the Y axis in the process.</span></span>
<span class="line"><span style="color:#6A737D">/// Optionally includes the half-texel offset necessary in DirectX9 to properly align to texels.</span></span>
<span class="line"><span style="color:#6A737D">/// &#x3C;/summary></span></span>
<span class="line"><span style="color:#E1E4E8">public </span><span style="color:#F97583">static</span><span style="color:#E1E4E8"> Matrix </span><span style="color:#B392F0">CreateTextureMatrix</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> texWidth, </span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> texHeight, </span><span style="color:#F97583">bool</span><span style="color:#E1E4E8"> includeHalfTexelOffset </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">bool</span><span style="color:#E1E4E8"> flipY </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#6A737D">    //Calculate translation for conversion + DX9 half-pixel offset</span></span>
<span class="line"><span style="color:#F97583">    float</span><span style="color:#E1E4E8"> xOffset </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.5</span><span style="color:#F97583">f</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> (includeHalfTexelOffset </span><span style="color:#F97583">?</span><span style="color:#79B8FF"> 0.5</span><span style="color:#F97583">f</span><span style="color:#F97583"> /</span><span style="color:#E1E4E8"> texWidth </span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    float</span><span style="color:#E1E4E8"> yOffset </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0.5</span><span style="color:#F97583">f</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> (includeHalfTexelOffset </span><span style="color:#F97583">?</span><span style="color:#79B8FF"> 0.5</span><span style="color:#F97583">f</span><span style="color:#F97583"> /</span><span style="color:#E1E4E8"> texHeight </span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    float</span><span style="color:#E1E4E8"> yScale </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> flipY </span><span style="color:#F97583">?</span><span style="color:#F97583"> -</span><span style="color:#79B8FF">0.5</span><span style="color:#F97583">f</span><span style="color:#F97583"> :</span><span style="color:#79B8FF"> 0.5</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    //We want to remap [-1,1] clip space to [0,1] texture space</span></span>
<span class="line"><span style="color:#6A737D">    //Multiplying a projected vector by the following matrix should give us</span></span>
<span class="line"><span style="color:#6A737D">    //x' = 0.5x + xOffset * w</span></span>
<span class="line"><span style="color:#6A737D">    //y' = -0.5y + yOffset * w</span></span>
<span class="line"><span style="color:#6A737D">    //z' = 0</span></span>
<span class="line"><span style="color:#6A737D">    //w' = w</span></span>
<span class="line"><span style="color:#E1E4E8">    Matrix matTex </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Matrix</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0.5</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">,    </span><span style="color:#79B8FF">0.0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">,    </span><span style="color:#79B8FF">0.0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">                               0.0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">,    yScale,  </span><span style="color:#79B8FF">0.0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">,</span><span style="color:#6A737D"> //Flip y axis</span></span>
<span class="line"><span style="color:#79B8FF">                               0.0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">,    </span><span style="color:#79B8FF">0.0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">,    </span><span style="color:#79B8FF">0.0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0.0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">                               xOffset, yOffset, </span><span style="color:#79B8FF">0.0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1.0</span><span style="color:#F97583">f</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> matTex;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" lang="cpp"><code><span class="line"><span style="color:#6A737D">//This sets the matrix for converting from world space to shadow-map texture coordinates. I</span></span>
<span class="line"><span style="color:#6A737D">//use the value in the vertex shader for rendering the scene.</span></span>
<span class="line"><span style="color:#E1E4E8">shadowEffect.Parameters[</span><span style="color:#9ECBFF">"LightViewProjTex0"</span><span style="color:#E1E4E8">].</span><span style="color:#B392F0">SetValue</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">                        light.View </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> light.Projection </span><span style="color:#F97583">*</span></span>
<span class="line"><span style="color:#B392F0">                        CreateTextureMatrix</span><span style="color:#E1E4E8">(shadowMap.Width, shadowMap.Height, </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" lang="hlsl"><code><span class="line"><span style="color:#6A737D">//The following is in the vertex shader for rendering the scene from the camera's POV</span></span>
<span class="line"><span style="color:#6A737D">//LightView0 is light.View</span></span>
<span class="line"><span style="color:#6A737D">//LightViewProj0 is light.View * light.Projection</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">float4</span><span style="color:#E1E4E8"> Po = </span><span style="color:#F97583">float4</span><span style="color:#E1E4E8">(IN.Position.xyz, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">//Object space position</span></span>
<span class="line"><span style="color:#F97583">float4</span><span style="color:#E1E4E8"> Pw = </span><span style="color:#F97583">float4</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">mul</span><span style="color:#E1E4E8">(Po, World).xyz, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">//World space position</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">//Calculate shadow map texture space position of vertex. The xy values will contain u*w and v*w.</span></span>
<span class="line"><span style="color:#6A737D">//We have to wait to perform this divide because otherwise the texture interpolator will muck it up.</span></span>
<span class="line"><span style="color:#E1E4E8">OUT.LightMap0 = </span><span style="color:#79B8FF">mul</span><span style="color:#E1E4E8">(Pw, LightViewProjTex0);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">if</span><span style="color:#E1E4E8">(UseLinearDepth)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">    float4</span><span style="color:#E1E4E8"> LightViewPos = </span><span style="color:#79B8FF">mul</span><span style="color:#E1E4E8">(Pw, LightView0); </span><span style="color:#6A737D">//Light-space position of vertex</span></span>
<span class="line"><span style="color:#E1E4E8">    OUT.LightMap0.z = (</span><span style="color:#79B8FF">abs</span><span style="color:#E1E4E8">(LightViewPos.z) - DepthRange.x) * DepthRange.y; </span><span style="color:#6A737D">//Store depth in the z coord</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#F97583">else</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">    float4</span><span style="color:#E1E4E8"> LightViewProjPos = </span><span style="color:#79B8FF">mul</span><span style="color:#E1E4E8">(Pw, LightViewProj0); </span><span style="color:#6A737D">//Projected light-space position of vertex</span></span>
<span class="line"><span style="color:#E1E4E8">    OUT.LightMap0.z = LightViewProjPos.z / LightViewProjPos.w; </span><span style="color:#6A737D">//Store depth in the z coord</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" lang="hlsl"><code><span class="line"><span style="color:#6A737D">//In the pixel shader, we need to perform the perspective divide on the uv coords. We can either do this directly and then use tex2D...</span></span>
<span class="line"><span style="color:#F97583">float2</span><span style="color:#E1E4E8"> shadowMapUV = IN.LightMap0.xy / IN.LightMap0.w;</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> shadowMapValue = </span><span style="color:#79B8FF">tex2D</span><span style="color:#E1E4E8">(shadowMapSampler, shadowMapUV);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">//Or we can use the tex2Dproj function to do the math for us</span></span>
<span class="line"><span style="color:#F97583">float4</span><span style="color:#E1E4E8"> shadowMapUV = IN.LightMap0;</span></span>
<span class="line"><span style="color:#F97583">float</span><span style="color:#E1E4E8"> shadowMapValue = </span><span style="color:#79B8FF">tex2Dproj</span><span style="color:#E1E4E8">(shadowMapSampler, shadowMapUV); </span><span style="color:#6A737D">//Performs xy / w automatically</span></span></code></pre>
<p>Most of what I have above is gleaned from <a href="https://diaryofagraphicsprogrammer.blogspot.com/2008/09/calculating-screen-space-texture.html">Diary of a Graphics Programmer</a> and <a href="https://www.gamedev.net/topic/301151-projective-texturing-and-tex2dproj/">gamedev.net</a>, though the former is a little confusing, as the half-pixel offset should be $\frac{1}{2 \times TargetWidth}$, not $\frac{TargetWidth}{2}$.</p></div></article></main><footer></footer></div></body></html>