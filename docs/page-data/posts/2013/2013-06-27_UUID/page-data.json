{"componentChunkName":"component---src-components-post-tsx","path":"/posts/2013/2013-06-27_UUID","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Universal Unique Identifiers\",\n  \"date\": \"2013-06-27T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Universal Unique Identifiers\"), mdx(\"p\", null, \"Of late I\\u2019ve been writing a fair amount of parsing code for some MPEG-4 ISO base media file format content (ISOBMFF from here on). These files are rather straightforward to parse: you can define a basic catch-all structure and add functionality for parsing specific chunks as you go. One issue I ran into recently, however, was a need to parse out some \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"byte[16]\"), \" blobs containing unique identifiers and display them as the hexadecimal UUIDs we\\u2019re familiar with (e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"6f8db96c-2908-4250-ba92-9a2d67ce6007\"), \"). Having written my parser in C#, my first thought was to do the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"byte[] data = parser.ReadByteArray(16); //Read in UUID data\\nGuid guid = new Guid(data);\\nstring formattedUuid = guid.ToString();\\n\")), mdx(\"p\", null, \"Unfortunately, this has a nasty problem.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"// Lets say my original UUID was:\\nstring uuidString = \\\"DEADBEEF-CAFE-BABE-DEED-0123456789AB\\\";\\n\\n// In binary form, per the UUID spec, this should be represented as the following:\\nbyte[] uuidBytes = new byte[]{ 0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xFE, 0xBA, 0xBE,\\n                               0xDE, 0xED, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB };\\n\\n// Lets try some things...\\nGuid guidFromString = new Guid(uuidString);\\nGuid guidFromData = new Guid(uuidBytes);\\n\\nguidFromString.ToString();     // DEADBEEF-CAFE-BABE-DEED-0123456789AB\\nguidFromString.ToByteArray();  // EF-BE-AD-DE-FE-CA-BE-BA-DE-ED-01-23-45-67-89-AB\\n\\nguidFromData.ToString();     // EFBEADDE-FECA-BEBA-DEED-0123456789AB\\nguidFromData.ToByteArray();  // DE-AD-BE-EF-CA-FE-BA-BE-DE-ED-01-23-45-67-89-AB\\n\")), mdx(\"p\", null, \"Say what? Why do the string and byte representations not match? And why are only the first three sections getting shuffled around?\"), mdx(\"h2\", null, \"Guids are tricky buggers\"), mdx(\"p\", null, \"Observe the Windows \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/windows/win32/api/guiddef/ns-guiddef-guid\"\n  }, \"GUID\"), \" structure. It stores its fields as follows (.NET does the same):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"typedef struct _GUID {\\n  DWORD Data1;\\n  WORD  Data2;\\n  WORD  Data3;\\n  BYTE  Data4[8];\\n} GUID;\\n\")), mdx(\"p\", null, \"See the issue? A clue: your processor might have something to do with it.\"), mdx(\"p\", null, \"When a .NET Guid object is created from a string, the Guid constructor knows that the values in the string are a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Endianness\"\n  }, \"big-endian\"), \" representation of the fields. The hex is parsed and stored into these fields so that the value remains the same \\u2014 for example, 0xDEADBEEF is 3735928559, so the value 3735928559 is stored in Data1. 0xCAFE is 51966, so Data2 = 51966, and so on.\"), mdx(\"p\", null, \"When \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ToString()\"), \" is called, the method will build a string that is back in the big-endian order. The string you put in is the string you get out.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"However\"), \", when a Guid created this way is serialized via the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ToByteArray()\"), \" method, it is essentially performing a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.cplusplus.com/reference/cstring/memcpy/\"\n  }, \"memcpy\"), \" of the structure. This means the binary representation is affected by the endianness of the system.\"), mdx(\"p\", null, \"The x86 and x86-64 architectures are little-endian. That DWORD value 3735928559 we previously stored is ordered in memory as 0xEFBEADDE. Each byte in Data4, meanwhile, is the same coming out as it was going in because endianness only affects the arrangement of bytes within a multi-byte field, not the order of bits within a single byte. \\u2018DEED-123456789AB\\u2019 (8 bytes total) is stored in the Data4 array, a sequence of individual bytes, hence why it remains the same throughout our tests while the the first three sections get shuffled around.\"), mdx(\"p\", null, \"Take note that when a Guid is created from a byte[], the assumption is that the input array is in the same order as what ToByteArray spits out. Again, all it does is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"memcpy\"), \" the data. If you pass it bytes in big-endian order, then call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ToString()\"), \", you\\u2019ll get a string in little-endian order.\"), mdx(\"h2\", null, \"The takeaway\"), mdx(\"p\", null, \"Given a string representation of a UUID, the .NET Guid object will input/output a matching string (big-endian order), but input/output of binary data is in little-endian order. Since this is annoying to remember, I\\u2019ve written up a simple Uuid structure below to help out by homogenizing the inputs and outputs.\"), mdx(\"h2\", null, \"Code Sample\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"/// <summary>\\n/// UUID implementation based on Guid. Behaves like a Guid except that inputs and outputs\\n/// (such as byte[] and strings) are consistent and match a fully big-endian representation\\n/// of the UUID structure.\\n/// </summary>\\n[Serializable]\\npublic struct Uuid : IFormattable, IComparable, IComparable<Uuid>, IEquatable<Uuid>\\n{\\n    //Internally, we use a Guid so that we can take advantage of most of its functionality.\\n    private Guid guid;\\n\\n    public static readonly Uuid Empty = new Uuid();\\n\\n    /// <summary>\\n    /// Creates a UUID from an array of bytes.\\n    /// Calls to ToString and ToByteArray will retrieve values in the same order as this initial input.\\n    /// </summary>\\n    /// <param name=\\\"uuid\\\"></param>\\n    public Uuid(byte[] uuidData)\\n    {\\n        if (BitConverter.IsLittleEndian)\\n        {\\n            //Little-endian system, so we need to deal with the mismatch between the input layout\\n            //and Guid's in-memory layout. We can solve this by reading the bytes into fields ourselves.\\n\\n            Int32 data1 = ((((((uuidData[0] << 8) | uuidData[1]) << 8) | uuidData[2]) << 8) | uuidData[3]);\\n            Int16 data2 = (Int16)((uuidData[4] << 8) | uuidData[5]);\\n            Int16 data3 = (Int16)((uuidData[6] << 8) | uuidData[7]);\\n\\n            guid = new Guid(data1, data2, data3, uuidData[8], uuidData[9], uuidData[10], uuidData[11],\\n                                                 uuidData[12], uuidData[13], uuidData[14], uuidData[15]);\\n        }\\n        else\\n        {\\n            //Big-endian system, so Guid's in-memory layout already matches incoming Uuid byte ordering.\\n            //We can allow Guid to use its shortcut memcpy construction routine.\\n            guid = new Guid(uuidData);\\n        }\\n    }\\n\\n    /// <summary>\\n    /// Creates a UUID from a hexadecimal string representation of the format XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX.\\n    /// Calls to ToString and ToByteArray will retrieve values in the same order as this initial input.\\n    /// </summary>\\n    /// <param name=\\\"uuid\\\"></param>\\n    public Uuid(string uuid)\\n    {\\n        guid = new Guid(uuid);\\n    }\\n\\n    /// <summary>\\n    /// Creates a UUID from a Windows Guid object.\\n    /// Calls to ToString will retrieve values matching Guid.ToString.\\n    /// Calls to ToByteArray will retrieve an array with values in the same order as the string representation.\\n    /// </summary>\\n    /// <param name=\\\"guid\\\"></param>\\n    public Uuid(Guid guid)\\n    {\\n        this.guid = guid;\\n    }\\n\\n    /// <summary>\\n    /// Retrieves a byte array representation of the UUID. Byte order matches the ToString representation.\\n    /// </summary>\\n    /// <returns></returns>\\n    public byte[] ToByteArray()\\n    {\\n        //ToByteArray returns a memcpy of the Guid structure\\n        byte[] guidData = guid.ToByteArray();\\n\\n        if (BitConverter.IsLittleEndian)\\n        {\\n            //Convert little-endian in-memory representation back into big-endian order\\n            Array.Reverse(guidData, 0, 4);\\n            Array.Reverse(guidData, 4, 2);\\n            Array.Reverse(guidData, 6, 2);\\n        }\\n\\n        return guidData;\\n    }\\n\\n    public static Uuid NewUuid()\\n    {\\n        return new Uuid() { guid = Guid.NewGuid() };\\n    }\\n\\n    public static bool operator !=(Uuid a, Uuid b)\\n    {\\n        return a.guid != b.guid;\\n    }\\n\\n    public static bool operator ==(Uuid a, Uuid b)\\n    {\\n        return a.guid == b.guid;\\n    }\\n\\n    public bool Equals(Uuid u)\\n    {\\n        return guid.Equals(u.guid);\\n    }\\n\\n    public override bool Equals(object o)\\n    {\\n        if(o is Uuid)\\n            return this.Equals((Uuid)o);\\n        return false;\\n    }\\n\\n    public override int GetHashCode()\\n    {\\n        return guid.GetHashCode();\\n    }\\n\\n    public int CompareTo(Uuid value)\\n    {\\n        return guid.CompareTo(value.guid);\\n    }\\n\\n    public int CompareTo(Object value)\\n    {\\n        if (value is Uuid)\\n            return guid.CompareTo(((Uuid)value).guid);\\n        else\\n            throw new ArgumentException(\\\"Value must be of type Uuid\\\");\\n    }\\n\\n    /// <summary>\\n    /// Retrieves a hexadecimal string representation with each byte corresponding\\n    /// to a hex tuple in left-to-right order, in the format XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\\n    /// </summary>\\n    public override string ToString()\\n    {\\n        return guid.ToString();\\n    }\\n\\n    public string ToString(string format)\\n    {\\n        return guid.ToString(format);\\n    }\\n\\n    public string ToString(string format, IFormatProvider provider)\\n    {\\n        return guid.ToString(format, provider);\\n    }\\n\\n    public static bool TryParse(string input, out Uuid result)\\n    {\\n        Guid guidResult;\\n        if (Guid.TryParse(input, out guidResult))\\n        {\\n            result = new Uuid() { guid = guidResult };\\n            return true;\\n        }\\n        else\\n        {\\n            result = Uuid.Empty;\\n            return false;\\n        }\\n    }\\n\\n    public static bool TryParseExact(string input, string format, out Uuid result)\\n    {\\n        Guid guidResult;\\n        if (Guid.TryParseExact(input, format, out guidResult))\\n        {\\n            result = new Uuid() { guid = guidResult };\\n            return true;\\n        }\\n        else\\n        {\\n            result = Uuid.Empty;\\n            return false;\\n        }\\n    }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"date":"June 27, 2013","title":"Universal Unique Identifiers","subtitle":null}}},"pageContext":{"id":"0bad7497-b48a-5e5a-a219-fe2fe8ff4d53"}},"staticQueryHashes":[]}