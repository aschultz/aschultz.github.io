{"componentChunkName":"component---src-components-post-tsx","path":"/posts/2015/2015-08-14_Excel","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Excel-ing at the speed of C\",\n  \"date\": \"2015-08-14T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Excel-ing at the speed of C\"), mdx(\"p\", null, \"Excel is a great tool, but some of its most powerful features are ancient, obscurely documented, or poorly designed. Case in point: Excel includes a Visual Basic scripting system allowing for creation of custom macros and programmatic control over documents. It can be quite useful, but is ultimately limited by the VBA language and type system \\u2014 stuck in a time before .NET, lacking even basic unsigned integer support. So what if we could break out of VBA and call into our own DLL?\"), mdx(\"p\", null, \"Thankfully, Excel can interop with basically any native DLL as long as it follows the right esoteric conventions. For example, let\\u2019s create a simple method in C that takes an input and returns it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"extern \\\"C\\\" int GetValue( int value )\\n{\\n    return value;\\n}\\n\")), mdx(\"p\", null, \"And in VBA\\u2026\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-vb\"\n  }, \"'' Declare the signature of the external function \\\"GetValue\\\" and where to find it\\nPrivate Declare Function GetValue Lib \\\"C:\\\\bin\\\\MyLib.dll\\\" (ByVal value As Long) As Long\\n\\n''' Declare a method we can run in Excel editor for debugging/testing\\nPublic Sub TestMyLib()\\n    Dim retVal As Long\\n\\n    retVal = GetValue(5) ''' Will set retVal to 5\\nEnd Function\\n\")), mdx(\"p\", null, \"There are several things to note here:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The C/C++ library must define methods as extern \\u201CC\\u201D so that they are exported without any C++ style name mangling. This is necessary so that VBA can find the method by name.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The data types in C and VB must match in size. An \\u201Cint\\u201D in C being 32-bit corresponds to the \\u201CLong\\u201D 32-bit type in VB, not the \\u201CInteger\\u201D type which is only 16 bits. Mismatches will cause either an Overflow error or a crash.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The VB method declaration requires specifying the path to the DLL. Normally this needs to be absolute; we\\u2019ll later discuss a workaround.\")), mdx(\"p\", null, \"Let\\u2019s take another step and say we want to read in a string storing an error code, convert it to a number, and send back a description of it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"extern \\\"C\\\" VARIANT GetErrorDescription( BSTR bstrErrorCode )\\n{\\n    unsigned long   dwErrorCode      = 0;\\n    const char    * pszErrName       = NULL;\\n    BSTR            bstrErrorMessage = NULL;\\n    int             cchErrorMessage  = 0;\\n    int             cchErrName       = 0;\\n    VARIANT         vnt;\\n\\n    // Parse integer from input string\\n    dwErrorCode = wcstoul(bstrErrorCode, NULL, 0);\\n\\n    // Call helper method that looks up the string for this error code\\n    pszErrName = GetErrorNameFromCode( dwErrorCode, NULL );\\n    cchErrName = (int)strlen(pszErrName);\\n\\n    // Convert message to UTF-16 so that we can store it in BSTR\\n    cchErrorMessage = MultiByteToWideChar(CP_UTF8, 0, pszErrName, cchErrName, NULL, 0);\\n    bstrErrorMessage = SysAllocStringLen(0, (unsigned int)cchErrorMessage);\\n    MultiByteToWideChar(CP_UTF8, 0, pszErrName, cchErrName, bstrErrorMessage, cchErrorMessage);\\n\\n    // Return as a VARIANT.\\n    // This is necessary to prevent VBA callers from mangling the string by\\n    // attempting to convert to UNICODE (VBA does this if the return value is just BSTR).\\n    VariantInit(&amp;amp;amp;amp;amp;vnt);\\n    vnt.vt = VT_BSTR;\\n    vnt.bstrVal = bstrErrorMessage;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-vb\"\n  }, \"Private Declare Function GetErrorDescription Lib \\\"C:\\\\bin\\\\MyLib.dll\\\" (ByVal value As LongPtr) As Variant\\n\\n''' Declare a method we can run in Excel editor for debugging/testing\\nPublic Sub TestMyLib()\\n    Dim retVal As String\\n\\n    retVal = GetErrorDescription(StrPtr(\\\"5\\\"))\\nEnd Function\\n\")), mdx(\"p\", null, \"Clearly this is bit more complex.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A string must be passed as a BSTR. Not a char \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \", or wchar \"), \", or std::string, or anything else. A BSTR is a special string data type designed for interop, containing a length-prefix, an array of wchar, and two null-terminating characters.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Despite Excel using BSTR internally and our method taking BSTR, Excel will take any \\u201CString\\u201D parameter or return value in the VBA Declare statement and run it through a Unicode to ASCII conversion. To avoid the mess this causes, we pass a pointer to the incoming BSTR and return a VARIANT type containing a BSTR. That avoids any automatic conversions.\")), mdx(\"h2\", null, \"Dynamic Paths\"), mdx(\"p\", null, \"At this point we can start using our native code do some heavy lifting, but we\\u2019re still stuck with a hard-coded path to the binary in our VBA. That\\u2019s rather limiting. We can leverage what we know so far, however, to hack in a solution.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-vb\"\n  }, \"Private Declare Function LoadLibrary Lib \\\"kernel32\\\" Alias \\\"LoadLibraryA\\\" (ByVal lpLibFileName As String) As LongPtr\\n\\nPrivate Declare Function GetErrorDescription Lib \\\"MyLib.dll\\\" (ByVal value As LongPtr) As Variant\\n\\nPublic Sub TestMyLib()\\n    Static hasLoadedLib As Boolean\\n    Dim retVal As String\\n\\n    If Not hasLoadedLib Then\\n        If LoadLibrary(ThisWorkbook.Path & \\\"\\\\\\\" & \\\"MyLib.dll\\\") <> 0 Then\\n            hasLoadedLib = True\\n        End If\\n    End If\\n\\n    retVal = GetErrorDescription(StrPtr(\\\"5\\\"))\\nEnd Function\\n\")), mdx(\"p\", null, \"First, we modify the Declare statement for our lib to mention just the filename. Then, since system libraries are accessible without a full path, we can call the system\\u2019s LoadLibrary method to dynamically load our DLL from whatever path we want \\u2014 in this case, the same folder as the workbook itself. Once the DLL is loaded into memory, Excel will happily use it without a second thought.\"), mdx(\"h2\", null, \"References\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://web.archive.org/web/20161116225951/https://msdn.microsoft.com/en-us/library/office/bb687915.aspx\"\n  }, \"How to: Access DLLs in Excel\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://web.archive.org/web/20161116225951/http://blog.nkadesign.com/2013/vba-unicode-strings-and-the-windows-api/\"\n  }, \"VBA: Unicode Strings and the Windows API\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://web.archive.org/web/20161116225951/http://blogs.msdn.com/b/ericlippert/archive/2003/09/12/52976.aspx\"\n  }, \"Eric\\u2019s Complete Guide To BSTR Semantics\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"date":"August 14, 2015","title":"Excel-ing at the speed of C","subtitle":null}}},"pageContext":{"id":"282842c4-8d24-52a4-8bca-9f931c1ea3be"}},"staticQueryHashes":[]}